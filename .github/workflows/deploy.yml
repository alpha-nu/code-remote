# Continuous Deployment - Serverless Architecture
# Deploys to AWS Lambda + S3/CloudFront
name: Deploy

on:
  push:
    branches:
      - main           # Deploy to dev on main branch push
    tags:
      - 'v*'           # Deploy to prod on version tags (v1.0.0, v1.2.3, etc.)
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - prod

# Prevent concurrent deployments to the same environment
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: us-east-1

jobs:
  # ============================================================
  # Setup: Determine environment and configuration
  # ============================================================
  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      stack: ${{ steps.env.outputs.stack }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
    steps:
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            ENV="prod"
          else
            ENV="dev"
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "stack=$ENV" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT

          echo "### Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | $ENV |" >> $GITHUB_STEP_SUMMARY
          echo "| Stack | $ENV |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Ref | ${{ github.ref }} |" >> $GITHUB_STEP_SUMMARY

  # ============================================================
  # Test: Run all tests before deployment
  # ============================================================
  test:
    name: Test
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"

      - name: Set up Python
        run: uv python install 3.11

      - name: Test Backend
        working-directory: backend
        run: |
          uv venv .venv
          source .venv/bin/activate
          uv pip install -e ".[dev]"
          pytest tests/unit/ -v --tb=short

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Test Frontend
        working-directory: frontend
        run: |
          npm ci
          npm run lint
          npm run type-check
          npm run test -- --run

  # ============================================================
  # Infrastructure: Deploy with Pulumi
  # ============================================================
  infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [setup, test]
    environment: ${{ needs.setup.outputs.environment }}
    outputs:
      api_ecr_url: ${{ steps.outputs.outputs.api_ecr_url }}
      api_function_name: ${{ steps.outputs.outputs.api_function_name }}
      api_endpoint: ${{ steps.outputs.outputs.api_endpoint }}
      frontend_bucket: ${{ steps.outputs.outputs.frontend_bucket }}
      frontend_distribution_id: ${{ steps.outputs.outputs.frontend_distribution_id }}
      frontend_url: ${{ steps.outputs.outputs.frontend_url }}
      cognito_user_pool_id: ${{ steps.outputs.outputs.cognito_user_pool_id }}
      cognito_client_id: ${{ steps.outputs.outputs.cognito_client_id }}
      websocket_endpoint: ${{ steps.outputs.outputs.websocket_endpoint }}
      migration_function_name: ${{ steps.outputs.outputs.migration_function_name }}
      sync_worker_function_name: ${{ steps.outputs.outputs.sync_worker_function_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: infra/pulumi/requirements.txt

      - name: Install Pulumi CLI
        uses: pulumi/actions@v5

      - name: Install Pulumi dependencies
        working-directory: infra/pulumi
        run: pip install -r requirements.txt

      - name: Pulumi Login
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: pulumi login

      - name: Select/Create Pulumi stack
        working-directory: infra/pulumi
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          pulumi stack select ${{ needs.setup.outputs.stack }} 2>/dev/null || \
          pulumi stack init ${{ needs.setup.outputs.stack }}

      - name: Pulumi Preview
        working-directory: infra/pulumi
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: pulumi preview --stack ${{ needs.setup.outputs.stack }}

      - name: Pulumi Deploy
        working-directory: infra/pulumi
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: pulumi up --yes --stack ${{ needs.setup.outputs.stack }}

      - name: Get Pulumi outputs
        id: outputs
        working-directory: infra/pulumi
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          echo "api_ecr_url=$(pulumi stack output ecr_api_repository_url)" >> $GITHUB_OUTPUT
          echo "api_function_name=$(pulumi stack output api_function_name)" >> $GITHUB_OUTPUT
          echo "api_endpoint=$(pulumi stack output api_endpoint)" >> $GITHUB_OUTPUT
          echo "frontend_bucket=$(pulumi stack output frontend_bucket_name)" >> $GITHUB_OUTPUT
          echo "frontend_distribution_id=$(pulumi stack output frontend_distribution_id)" >> $GITHUB_OUTPUT
          echo "frontend_url=$(pulumi stack output frontend_url)" >> $GITHUB_OUTPUT
          echo "cognito_user_pool_id=$(pulumi stack output cognito_user_pool_id)" >> $GITHUB_OUTPUT
          echo "cognito_client_id=$(pulumi stack output cognito_user_pool_client_id)" >> $GITHUB_OUTPUT
          echo "websocket_endpoint=$(pulumi stack output websocket_endpoint)" >> $GITHUB_OUTPUT
          echo "migration_function_name=$(pulumi stack output migration_function_name)" >> $GITHUB_OUTPUT
          echo "sync_worker_function_name=$(pulumi stack output sync_worker_function_name 2>/dev/null || echo '')" >> $GITHUB_OUTPUT

  # ============================================================
  # Build: Build and push Docker images
  # ============================================================
  build-api:
    name: Build API Image
    runs-on: ubuntu-latest
    needs: [setup, infrastructure]
    environment: ${{ needs.setup.outputs.environment }}
    outputs:
      image_uri: ${{ steps.build.outputs.image_uri }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push API image
        id: build
        env:
          ECR_URL: ${{ needs.infrastructure.outputs.api_ecr_url }}
          SHA: ${{ github.sha }}
        run: |
          SHORT_SHA="${SHA:0:7}"
          IMAGE_URI="${ECR_URL}:${SHORT_SHA}"

          docker buildx build \
            --platform linux/amd64 \
            --provenance=false \
            --push \
            -t "${IMAGE_URI}" \
            -t "${ECR_URL}:latest" \
            -f backend/Dockerfile.lambda \
            backend/

          echo "image_uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "Built and pushed: ${IMAGE_URI}"

  # ============================================================
  # Deploy Backend: Update Lambda function
  # ============================================================
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [setup, infrastructure, build-api]
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update Lambda function
        env:
          FUNCTION_NAME: ${{ needs.infrastructure.outputs.api_function_name }}
          IMAGE_URI: ${{ needs.build-api.outputs.image_uri }}
        run: |
          echo "Updating Lambda function: $FUNCTION_NAME"
          echo "With image: $IMAGE_URI"

          aws lambda update-function-code \
            --function-name "$FUNCTION_NAME" \
            --image-uri "$IMAGE_URI" \
            --region ${{ env.AWS_REGION }}

          # Wait for update to complete
          echo "Waiting for Lambda update to complete..."
          aws lambda wait function-updated \
            --function-name "$FUNCTION_NAME" \
            --region ${{ env.AWS_REGION }}

          echo "Lambda function updated successfully"

      - name: Update Migration Lambda
        env:
          FUNCTION_NAME: ${{ needs.infrastructure.outputs.migration_function_name }}
          IMAGE_URI: ${{ needs.build-api.outputs.image_uri }}
        run: |
          echo "Updating Migration Lambda: $FUNCTION_NAME"
          echo "With image: $IMAGE_URI"

          aws lambda update-function-code \
            --function-name "$FUNCTION_NAME" \
            --image-uri "$IMAGE_URI" \
            --region ${{ env.AWS_REGION }}

          aws lambda wait function-updated \
            --function-name "$FUNCTION_NAME" \
            --region ${{ env.AWS_REGION }}

          echo "Migration Lambda updated successfully"

      - name: Update Sync Worker Lambda
        if: ${{ needs.infrastructure.outputs.sync_worker_function_name != '' }}
        env:
          FUNCTION_NAME: ${{ needs.infrastructure.outputs.sync_worker_function_name }}
          IMAGE_URI: ${{ needs.build-api.outputs.image_uri }}
        run: |
          echo "Updating Sync Worker Lambda: $FUNCTION_NAME"
          echo "With image: $IMAGE_URI"

          aws lambda update-function-code \
            --function-name "$FUNCTION_NAME" \
            --image-uri "$IMAGE_URI" \
            --region ${{ env.AWS_REGION }}

          aws lambda wait function-updated \
            --function-name "$FUNCTION_NAME" \
            --region ${{ env.AWS_REGION }}

          echo "Sync Worker Lambda updated successfully"

      - name: Run database migrations
        env:
          FUNCTION_NAME: ${{ needs.infrastructure.outputs.migration_function_name }}
        run: |
          echo "Running database migrations..."

          # Invoke migration Lambda and capture response
          RESPONSE=$(aws lambda invoke \
            --function-name "$FUNCTION_NAME" \
            --payload '{}' \
            --region ${{ env.AWS_REGION }} \
            --cli-binary-format raw-in-base64-out \
            /tmp/migration-response.json 2>&1)

          echo "Lambda invoke response: $RESPONSE"
          echo "Migration output:"
          cat /tmp/migration-response.json

          # Check if migration succeeded
          STATUS_CODE=$(jq -r '.statusCode' /tmp/migration-response.json)
          if [ "$STATUS_CODE" = "200" ]; then
            echo "âœ… Database migrations completed successfully!"
          else
            echo "âŒ Database migrations failed!"
            jq -r '.body' /tmp/migration-response.json | jq .
            exit 1
          fi

      - name: Verify deployment
        env:
          API_ENDPOINT: ${{ needs.infrastructure.outputs.api_endpoint }}
        run: |
          echo "Verifying API health..."
          for i in {1..5}; do
            if curl -sf "${API_ENDPOINT}/health"; then
              echo ""
              echo "âœ… Health check passed!"
              exit 0
            fi
            echo "Attempt $i failed, retrying in 5s..."
            sleep 5
          done
          echo "âŒ Health check failed after 5 attempts"
          exit 1

  # ============================================================
  # Deploy Frontend: Build and sync to S3
  # ============================================================
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [setup, infrastructure]
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Create environment file
        working-directory: frontend
        env:
          VITE_API_URL: ${{ needs.infrastructure.outputs.api_endpoint }}
          VITE_COGNITO_USER_POOL_ID: ${{ needs.infrastructure.outputs.cognito_user_pool_id }}
          VITE_COGNITO_CLIENT_ID: ${{ needs.infrastructure.outputs.cognito_client_id }}
          VITE_COGNITO_REGION: ${{ env.AWS_REGION }}
          VITE_WEBSOCKET_URL: ${{ needs.infrastructure.outputs.websocket_endpoint }}
        run: |
          cat > .env.production << EOF
          VITE_API_URL=${VITE_API_URL}
          VITE_COGNITO_USER_POOL_ID=${VITE_COGNITO_USER_POOL_ID}
          VITE_COGNITO_CLIENT_ID=${VITE_COGNITO_CLIENT_ID}
          VITE_COGNITO_REGION=${VITE_COGNITO_REGION}
          VITE_WEBSOCKET_URL=${VITE_WEBSOCKET_URL}
          EOF
          echo "Created .env.production:"
          cat .env.production

      - name: Build frontend
        working-directory: frontend
        run: npm run build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        working-directory: frontend
        env:
          S3_BUCKET: ${{ needs.infrastructure.outputs.frontend_bucket }}
        run: |
          # Sync static assets with long cache
          aws s3 sync dist/ "s3://${S3_BUCKET}/" \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "index.html" \
            --exclude "*.json"

          # Upload index.html with no-cache (always check for updates)
          aws s3 cp dist/index.html "s3://${S3_BUCKET}/index.html" \
            --cache-control "public, max-age=0, must-revalidate"

      - name: Invalidate CloudFront
        env:
          DISTRIBUTION_ID: ${{ needs.infrastructure.outputs.frontend_distribution_id }}
        run: |
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "$DISTRIBUTION_ID" \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)

          echo "CloudFront invalidation created: $INVALIDATION_ID"
          echo "Frontend URL: ${{ needs.infrastructure.outputs.frontend_url }}"

  # ============================================================
  # Smoke Tests: Verify deployment
  # ============================================================
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [setup, infrastructure, deploy-backend, deploy-frontend]
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Wait for CloudFront propagation
        run: sleep 30

      - name: Test API endpoints
        env:
          API_ENDPOINT: ${{ needs.infrastructure.outputs.api_endpoint }}
        run: |
          echo "Testing API endpoints at: $API_ENDPOINT"

          # Test health endpoint
          echo "=== Testing /health ==="
          curl -sf "${API_ENDPOINT}/health" | jq .

          # Test that protected endpoints require auth
          echo ""
          echo "=== Testing /execute requires auth ==="
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST "${API_ENDPOINT}/execute" \
            -H "Content-Type: application/json" \
            -d '{"code": "print(1)"}')

          if [ "$STATUS" = "401" ]; then
            echo "âœ… Auth correctly required (401)"
          else
            echo "âŒ Expected 401, got $STATUS"
            exit 1
          fi

      - name: Test frontend
        env:
          FRONTEND_URL: ${{ needs.infrastructure.outputs.frontend_url }}
        run: |
          echo "Testing frontend at: $FRONTEND_URL"

          # Check that frontend loads
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$FRONTEND_URL")

          if [ "$STATUS" = "200" ]; then
            echo "âœ… Frontend loads successfully"
          else
            echo "âŒ Frontend returned $STATUS"
            exit 1
          fi

  # ============================================================
  # Summary: Final deployment report
  # ============================================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [setup, infrastructure, deploy-backend, deploy-frontend, smoke-tests]
    if: always()
    steps:
      - name: Generate summary
        env:
          ENV: ${{ needs.setup.outputs.environment }}
          API_URL: ${{ needs.infrastructure.outputs.api_endpoint }}
          FRONTEND_URL: ${{ needs.infrastructure.outputs.frontend_url }}
          BACKEND_RESULT: ${{ needs.deploy-backend.result }}
          FRONTEND_RESULT: ${{ needs.deploy-frontend.result }}
          SMOKE_RESULT: ${{ needs.smoke-tests.result }}
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | **$ENV** |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Triggered by | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Ref | ${{ github.ref }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Endpoints" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend:** $FRONTEND_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **API:** $API_URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$BACKEND_RESULT" = "success" ]; then
            echo "- âœ… Backend deployment: Success" >> $GITHUB_STEP_SUMMARY
          else
            echo "- âŒ Backend deployment: $BACKEND_RESULT" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "$FRONTEND_RESULT" = "success" ]; then
            echo "- âœ… Frontend deployment: Success" >> $GITHUB_STEP_SUMMARY
          else
            echo "- âŒ Frontend deployment: $FRONTEND_RESULT" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "$SMOKE_RESULT" = "success" ]; then
            echo "- âœ… Smoke tests: Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- âš ï¸ Smoke tests: $SMOKE_RESULT" >> $GITHUB_STEP_SUMMARY
          fi
